#!/usr/bin/env bash

# file      : generate
# license   : Boost Software License 1.0; see accompanying LICENSE file

# Create build2 packages for the Boost C++ libraries.
#
# Use the official Boost superproject repository at
# https://github.com/boostorg/boost as source. Generate bpkg git repository
# containing Boost C++ library packages.
#
# --version-suffix <suffix>
#
#   A suffix to be added to the Boost version while deriving the library
#   packages version, or empty to use the Boost version unmodified. If this
#   option is omitted a suffix of "-a.0.z" will be used.
#

owd="$(pwd)"
trap "{ cd '$owd'; exit 1; }" ERR
set -o errtrace     # Trap in functions and subshells.
set -o pipefail     # Fail if any pipeline command fails.
shopt -s lastpipe   # Execute last pipeline command in the current shell.
shopt -s nullglob   # Expand no-match globs to nothing rather than themselves.

function info () { echo "$*" 1>&2; }
function error () { info "$*"; exit 1; }

# A suffix to be applied to the Boost version in the `version` package
# manifest field. (See the `--version-suffix` option above.)
#
version_suffix="-a.0.z"

while [[ "$#" -gt 0 ]]; do
  case "$1" in
    --version-suffix)
      shift
      version_suffix="$1"
      shift || true
      ;;
    -*)
      error "unknown option: $1"
      ;;
    # End of options.
    #
    *)
      error "unexpected '$1'"
      break
      ;;
  esac
done

# Get the Boost version from upstream/. See the root README for more info.
#
r="$(sed -n -Ee "s%^#\s*define\s+BOOST_VERSION\s+([0-9]+)%\1%p" \
         upstream/libs/config/include/boost/version.hpp)"

# At this point `r` will have a value like `107501` for Boost release 1.75.1.
# (The following arithmetic is specified in
# upstream/libs/config/include/boost/version.hpp.)
#
boostver="$(($r / 100000)).$((($r / 100) % 1000)).$(($r % 100))"

# Remove files/directories about to be generated, if they already exist.
#
rm -rf .gitignore .gitattributes \
       .bdep buildfile repositories.manifest packages.manifest \
       levels dependencies boostdep libboost-*

# Compile boostdep.
#
# Note that here we rely on the boost_filesystem library of a suitable version
# to be installed into the system. Building boostdep only using source files
# in the upstream/ directory feels too complicated at the moment since
# boost-filesystem has quite a lot of dependencies.
#
c++ -o boostdep upstream/tools/boostdep/src/boostdep.cpp -lboost_filesystem

# Produce the library dependency levels file.
#
# Libraries at a given dependency level depend only on libraries at lower
# levels. So those at level 0 have no dependencies while those at level 2
# depend only on libraries at levels 0 and/or 1, and so on.
#
# Use `boostdep` to group the Boost libraries by dependency level and parse
# that output into our own format which we write to a file named `levels`.
#
# The output produced by `boostdep` looks like this:
#
#   Module Levels:
#
#   Level 0:
#       (unknown)
#       callable_traits
#       compatibility
#       config
#       ...
#
#   Level 1:
#       assert -> config(0)
#       io -> config(0)
#       ...
#
#   Level 2:
#       core -> assert(1) config(0)
#       ...
#   ...
#
# A tilde (~) in the library name means a directory separator, for example,
# numeric~conversion.
#
# `boostdep` classifies the inclusion of a header as a dependency on the
# "(unknown)" library (which will naturally always be at level 0) if it did
# not find the included header under any of the
# `upstream/libs/<lib>/include/boost/` directories during its header-indexing
# search. This is usually the result of headers having been (re)moved or, in a
# handful of cases, belonging to optional external libraries. The (re)moved
# headers are normally included conditionally for some outdated configurations
# and their inclusions are picked up by `boostdep` since it doesn't handle the
# `#if` preprocessor directive. In general, the include paths triggering
# "(unknown)" cannot refer to any header that is part of a current and
# complete Boost distribution because it is a project-wide requirement that
# headers reside under `upstream/libs/<lib>/include/boost/` and this is below
# the starting point of `boostdep`'s header-indexing search. To get a list of
# these headers run:
#
#   ./boostdep --boost-root upstream --list-missing-headers
#
# Our output file, `levels`, contains one dependency level's libraries per
# line, starting at level 0, with each level's libraries separated by spaces,
# like this:
#
#   callable_traits compatibility config hof
#   assert io polygon static_assert
#   core stl_interfaces system throw_exception type_traits
#
sep=
./boostdep --boost-root upstream --module-levels | while read line; do

  # If we're at a new, non-zero dependency level then begin a new line of
  # output.
  #
  if [[ "$line" == "Level "[1-9]* ]]; then
    echo
    sep=

  # 1. Match lines like "<libname> -> <dep0> <dep1>...\n" (which are libraries
  #    at a non-zero level).
  #
  # 2. Skip the "(unknown)\n" line.
  #
  # 3. Match (non-empty) lines that do not contain any colons, thus matching
  #    lines like "<libname>\n" (which are libraries at level 0), but skipping
  #    the "Module Levels:\n" and "Level 0:\n" lines.
  #
  elif [[ ("$line" =~ (.+)" -> ") ||
          (("$line" != "(unknown)") && ("$line" =~ (^[^:]+$))) ]]; then
    echo -n "$sep${BASH_REMATCH[1]}"
    sep=' '
  fi
done > levels

echo >> levels # Terminate the last line.

# Convert a library name in `boostdep` format (see above) to a build2 package
# name and write it to stdout.
#
# The build2 package name is derived from the `boostdep` name by prefixing it
# with "libboost-" and replacing all underscores and tildes with hyphens. For
# example:
#
#   compatibility    -> libboost-compatibility
#   callable_traits  -> libboost-callable-traits
#   numeric~interval -> libboost-numeric-interval
#
# This script uses this format (which we will call "our") everywhere with a
# few exceptions: the `levels` and `dependencies` files and the values (not
# keys) in the `intf_deps` and `impl_deps` associative arrays, in both of
# which cases we keep the original; and library build target names where, for
# compatibility with system-installed library names, we use what is
# essentially the upstream name (see `upstream_name()`).
#
function pkg_name () # <library-name>
{
  echo "libboost-$(sed -Ee "s%[~_]%-%g" <<<"$1")"
}

# Convert a library name in `boostdep` format (see above) to an upstream
# library name and write it to stdout.
#
# In the majority of cases the upstream library name is identical to the
# `boostdep` name, except for those few libraries whose directories are not
# directly under `upstream/libs/`, in which cases `boostdep`'s tildes are
# replaced with underscores. For example:
#
#   numeric~foo_bar -> numeric_foo_bar
#
# Note that all of the libraries under `upstream/libs/numeric/` will be given
# this "numeric_" prefix whereas the Boost project only applies it to
# `numeric/conversion` (for example, they use just `ublas` and
# `interval`). But our way is more consistent and works out simpler for our
# purposes (they are header-only so there is no issues with binary library
# names). Because this divergence is limited to a tiny minority of libraries,
# "upstream_name" is still considered to be an appropriate name for this
# function.
#
function upstream_name () # <library-name>
{
  echo "$(sed -Ee "s%~%_%g" <<<"$1")"
}

# Read the library exclusions list from the file named `exclude` into the
# `lib_excl` associative array.
#
# This file contains one library/package name per line, in our format. For
# example:
#
#   libboost-callable-traits
#   libboost-compatibility
#   libboost-numeric-interval
#
declare -A lib_excl=()
cat exclude | while read line; do
  lib_excl["$line"]=true
done

# Create an empty build2 project in the root directory.
#
bdep new --type empty

# Append, to the new .gitignore, generated files that are not to be checked
# in. (`.gitignore` was just generated by `bdep new` above.)
#
cat << EOF >> .gitignore

# The generated files.
#
/boostdep

# Intermediate files.
#
*.bak
EOF

# Edit a file in-place with `sed` in the extended regex mode.
#
# Additional `sed` options may be passed after <file-path>.
#
function ised () # <file-path> <sed-option>...
{
  local f="$1"                  # File path.
  shift
  local o=("$@")                # Options to pass to `sed`.

  # `sed -i<backup-extension>` is not in POSIX but works on Linux, the BSDs,
  #  and Mac OS. The extension is optional on Linux but not the BSDs so must
  #  be provided.
  #
  sed -E -i.bak "${o[@]}" "$f"
  rm -f "$f.bak"
}

# Load various overrides from the override file. See this file for the
# overrides semantics.
#
declare -A manifest_url=()
declare -A manifest_builds=()
source override

# The Boost version, but formatted for use in the `doc-url` package manifest
# field. This is just `boostver` with everything but the major, minor, and
# patch components removed and all '.' replaced with '_'. For example,
# "1.75.1.beta1" -> "1_75_1". Note that Boost doesn't publish documentation
# for pre-releases.
#
doc_url_ver="$(sed -E -e "s%^([0-9]+\.[0-9]+\.[0-9]+).*%\1%" \
                      -e "s%\.%_%g" \
                      <<<"$boostver")"

# Detect the language of an upstream Boost library.
#
# Return, by writing to stdout, one of "c++", "c", or "mixed". Fail if unable
# to detect the language.
#
# All of a Boost library's source files reside in `src/` (see
# https://www.boost.org/development/requirements.html#Organization) so if
# there is no such directory then a library has no source files.
#
function detect_lang () # <lib-dir-path>
{
  local d="$1" # Upstream library directory path.

  local cxx
  cxx="$(find "$d/include/boost" -type f -name "*.hpp")"

  if [[ -z "$cxx" && -d "$d/src" ]]; then
    cxx="$(find "$d/src" -type f -name "*.cpp")"
  fi

  local c
  c="$(find "$d/include/boost" -type f -name "*.h")"

  if [[ -z "$c" && -d "$d/src" ]]; then
    c="$(find "$d/src" -type f -name "*.c")"
  fi

  if [[ -n "$cxx" && -n "$c" ]]; then
    echo "mixed"
  elif [[ -n "$cxx" ]]; then
    echo "c++"
  elif [[ -n "$c" ]]; then
    echo "c"
  else
    error "unable not detect the language of $d"
  fi
}

# Determine the dependencies between Boost libraries. Create a mapping from
# each Boost library to the other Boost libraries it depends on.
#
# `boostdep --module-overview` outputs the dependencies (other Boost libraries
#  only) of each Boost library in the following format (dependent to the left
#  and dependencies to the right of the arrow):
#
#    ...
#    align -> assert config core static_assert
#    any -> config core static_assert throw_exception type_index type_traits
#    array -> assert config core static_assert throw_exception
#    ...
#
# Note that `boostdep` sorts the dependent and dependency library names
# alphabetically (a fact that we take advantage of later).
#
# By default `boostdep` searches only header files for include statements
# (that is, it outputs only interface dependencies) but it will also search
# source files if the `--track-sources` flag is passed and thus we can get it
# to additionally include implementation dependencies in the output.
#
# Classify dependencies as interface or implementation by first outputting the
# interface dependencies only and storing those in `intf_deps`, an associative
# array indexed by the build2 package name and with values taken directly from
# the right-hand side of the arrow in the `boostdep` output above. For
# example:
#
#   ...
#   [libboost-align]="assert config core static_assert"
#   [libboost-any]="config core static_assert throw_exception..."
#   [libboost-array]="assert config core static_assert throw_exception"
#   ...
#
# Then run `boostdep` again, this time including implementation dependencies
# in the output. For each dependency, if it is already in `intf_deps` then its
# interface dependency status takes precedence; otherwise it is an
# implementation(-only) dependency and is added to the `impl_deps` associative
# array (which has the same structure as `intf_deps`).
#
# Also write each library's interface and implementation dependencies to a
# file called `dependencies` to be put under version control in order to alert
# us to dependency changes.
#
# The file has two lines for each library: the first for its interface
# dependencies and the second for its implementation dependencies. Each line
# begins with the library name followed by a colon and, if there are
# dependencies of that type, a space followed by the space-separated list of
# dependencies. The lines are sorted alphabetically by library name. All
# library names are in the `boostdep` format. For example:
#
#   ...
#   assert: config
#   assert:
#   assign: array config core move mpl preprocessor...
#   assign:
#   atomic: assert config static_assert type_traits winapi
#   atomic: align predef preprocessor
#   ...
#
# This format was designed for line-based diffs.
#
declare -A intf_deps=() # Interface dependencies for all libraries.
declare -A impl_deps=() # Implementation dependencies for all libraries.

# Gather interface dependencies for all libraries.
#
./boostdep --boost-root upstream \
           --module-overview | while read line; do
  if [[ "$line" =~ (.+)" -> "(.+) && -n "${BASH_REMATCH[2]}" ]]; then
    pn="$(pkg_name ${BASH_REMATCH[1]})" # build2 package name.

    # Remove the "(unknown)" dependency using the Bash pattern substitution
    # parameter expansion form.
    #
    # Note that we add the leading space to ease serialization into the
    # dependencies file (see below).
    #
    intf_deps["$pn"]=" ${BASH_REMATCH[2]/(unknown) /}"
  fi
done

# Gather implementation dependencies for all libraries.
#
# Also write the `dependencies` file in this loop in order to take advantage
# of the fact that the dependent library names are already sorted
# alphabetically in `boostdep`'s output.
#
# Note that --track-sources must be specified before --module-overview.
#
./boostdep --boost-root upstream \
           --track-sources \
           --module-overview | while read line; do
  if [[ "$line" =~ (.+)" -> "(.+) ]]; then
    lib="${BASH_REMATCH[1]}"              # Library name in `boostdep` format.
    pn="$(pkg_name $lib)"                 # build2 package name.
    deps=(${BASH_REMATCH[2]/(unknown) /}) # Dependencies minus "(unknown)".

    # Exclude implementation dependencies that are also interface dependencies
    # because the latter takes precedence.
    #
    ifdeps=(${intf_deps["$pn"]}) # Interface dependencies for this package.
    for i in "${!deps[@]}"; do
      for d in "${ifdeps[@]}"; do
        if [[ "$d" == "${deps[$i]}" ]]; then
          unset "deps[$i]"
          break
        fi
      done
    done

    # Save the dependencies in `impl_deps`, if any.
    #
    if [[ "${#deps[@]}" -ne 0 ]]; then
      impl_deps["$pn"]=" ${deps[@]}"
    fi

    # Now that we have all interface and all implementation dependencies for
    # this library, append them to the `dependencies` file.
    #
    echo "$lib:${intf_deps[$pn]}" >> dependencies
    echo "$lib:${impl_deps[$pn]}" >> dependencies
  fi
done

# Add dependencies to a library's package manifest and buildfiles.
#
# The <manifest> and <buildfile> arguments are the paths to the files to
# edit. The <deps> argument is a space-separated list of the package's
# dependencies in the `boostdep` name format. The <bf-var> argument is the
# name of the buildfile variable to modify: either "intf_libs" or "impl_libs".
#
function add_deps () # <manifest> <buildfile> <deps> <bf-var>
{
  local mf="$1"   # Path to the manifest.
  local bf="$2"   # Path to the buildfile.
  local deps=($3) # Dependencies (`boostdep` format).
  local vn="$4"   # Buildfile variable name.

  # Build a list of editing scripts for each file, then pass them all at once
  # to `sed`, thus invoking it only once per file.
  #
  local mscr=() # Sed scripts for the package manifest.
  local bscr=() # Sed scripts for the library buildfile.

  local i
  for i in "${!deps[@]}"; do
    local d="${deps[$i]}"             # Dependency in `boostdep` format.
    local dpn="$(pkg_name "$d")"      # Dependency's build2 package name.
    local dun="$(upstream_name "$d")" # Dependency upstream name.

    # Append the current dependency to the package manifest in a new line.
    #
    mscr+=(-e "/^depends: \* bpkg/adepends: $dpn == $")

    # Update the "(intf|impl)_libs = ..." Buildfile variable with the current
    # dependency.
    #
    # @@ TODO: make this conditional if the dependency is only required under
    #    some circumstances. For example, libboost-winapi is only built on
    #    Windows so don't depend on it unless building on Windows. Maybe we
    #    can reuse the manifest_builds overrides for that somehow? We also
    #    still lack the corresponding mechanism in manifest (conditional
    #    dependencies).
    #
    local dt="$dpn%lib\{boost_$dun\}" # Dependency text.
    if [[ "$i" -eq 0 ]]; then # First dependency: initialize variable.
      local a=" = " # The formatted assignment operator.
      if [[ "${#deps[@]}" -gt 1 ]]; then
        a="  = " # More deps coming, so adjust to align with " += "
      fi
      bscr+=(-e "s/^$vn = #.*/import $vn$a$dt/")
    else # Subsequent dependencies: update/append to variable.
      bscr+=(-e "/^import $vn.*/aimport $vn += $dt")
    fi
  done

  # Edit the files if there are dependencies.
  #
  if [[ "${#deps[@]}" -ne 0 ]]; then
    ised "$mf" "${mscr[@]}"
    ised "$bf" "${bscr[@]}"
  fi
}

# Generate a build2 project/package for each Boost library and add them as
# packages to the root project.
#
# Do one dependency level at a time, starting at level 0.
#
# @@ Currently for dependency levels 0-1 only.
#
# @@ Package manifest values yet to be customized:
#
#    - email: currently using boost-users@boost.org but we'll probably be
#      switching to the maintainer email addresses in
#      upstream/libs/<lib>/meta/libraries.json.
#
level=0
cat levels | while [[ "$level" -le 1 ]] && read line; do
  libs=($line) # The libraries at the current dependency level.

  # Create a build2 project for each library at the current dependency level.
  #
  # Note that `lib` is the `boostdep` library name (see above).
  #
  for lib in "${libs[@]}"; do
    udn="$(sed -Ee "s%~%/%g" <<<"$lib")" # Upstream directory name.
    udp="upstream/libs/$udn"             # Upstream directory path.
    un="$(upstream_name "$lib")"         # Upstream library name.
    pn="$(pkg_name "$lib")"              # build2 package name.

    # Skip this library if it's in the exclusion list.
    #
    if [[ -v "lib_excl[$pn]" ]]; then
      info "skipping $pn (excluded)"
      continue
    fi

    # Skip compiled libraries for the time being.
    #
    # @@ None of the ones at levels 0-1 happen to be compiled.
    #
    if [[ -d "$udp/src" ]]; then
      info "skipping $pn (compiled libraries not yet supported)"
      continue
    fi

    # Configure language-specific settings.
    #
    lo= # Suboptions to `bdep-new` `--lang` option.
    he= # Header file extension.
    se= # Source file extension.

    lang="$(detect_lang "$udp")"
    case "$lang" in
      c++)
        lo="c++,hxx=hpp,cxx=cpp"
        he="hpp"
        se="cpp"
        ;;
      c)
        lo="c"
        he="h"
        se="c"
        ;;
      mixed)
        # Skip this library unless it's pure C++ or pure C.
        #
        # @@ TODO: waiting on bdep-new support.
        #
        info "skipping $pn (mixed-language projects not yet supported)"
        continue
        ;;
    esac

    # Suboptions to `bdep-new` `--type` option.
    #
    to="lib,split,subdir=boost,no-version"

    # Detect binless libraries. (See `detect_lang()` for why we only check for
    # the presence of the `src` directory).
    #
    lib_bfile= # Buildfile which declares the library target.

    if [[ -d "$pn/src" ]]; then # Binful library.
      lib_bfile="$pn/src/buildfile"
    else                        # Binless library.
      lib_bfile="$pn/include/boost/buildfile"
      to+=",binless"
    fi

    # Create a build2 project for the current library, adding it as a package
    # to the root project.
    #
    # Let's create the LICENSE file prior to creating the package, so that
    # bdep-new can pick it up (detect the license manifest value, add it to
    # the buildfile, etc).
    #
    mkdir "$pn"
    ln -s "../LICENSE" "$pn"

    # Add upstream's README.md, if present, to the project.
    #
    # Note that bdep-new doesn't recognize Boost's README.md format and issues
    # the warning. Thus, we replace the generated file after it is created.
    #
    if [[ ! -f "$udp/README.md" ]]; then
      to+=",no-readme"
    fi

    bdep new --package --lang "$lo" --type "$to" "$pn"

    if [[ -f "$pn/README.md" ]]; then
      ln -sf "../$udp/README.md" "$pn"
    fi

    # Remove the bdep-generated header.
    #
    rm "$pn/include/boost/${pn#lib}.$he"

    # Create symlinks to the upstream headers inside the new project
    # directory.
    #
    for f in "$udp/include/boost/"*; do
      ln -s "../../../$f" "$pn/include/boost/"
    done

    # Derive the project url package manifest value (see the override file for
    # deviations).
    #
    if [[ -v "manifest_url[$pn]" ]]; then
      url="${manifest_url[$pn]}"
    else
      url="https://github.com/boostorg/$un"
    fi

    # The `doc-url` package manifest field, which refers to the documentation
    # for the packaged (not latest) version of the current library. Note that,
    # unlike the GitHub URL, the project name component of the documentation
    # URL is the upstream directory name instead of the upstream library
    # name. For example:
    #
    #   https://www.boost.org/doc/libs/1_75_1/libs/numeric/ublas
    #
    doc_url="https://www.boost.org/doc/libs/$doc_url_ver/libs/$udn"

    ised_ops=(\
      -e "s%^(version:).+%\1 $boostver$version_suffix%" \
      -e "s%^(url:).+%\1 $url%" \
      -e "/^url:/adoc-url: $doc_url" \
      -e "s%^(email:).+%\1 boost-users@lists.boost.org  ; Mailing list.%" \
      -e "s%^#(build-error-email:).+%\1 builds@build2.org%" \
      -e "/^#depends:/d" \
      -e "/^license:/atopics: C++, Boost" \
      -e "/^url:/apackage-url: https://github.com/build2-packaging/boost" \
      -e "/^email:/apackage-email: packaging@build2.org ; Mailing list.")

    # The `builds` package manifest value (see the override file for
    # deviations).
    #
    if [[ -v "manifest_builds[$pn]" ]]; then
      ised_ops+=(-e "/build-error-email/abuilds: ${manifest_builds[$pn]}")
    fi

    # Fix up the package manifest.
    #
    ised "$pn/manifest" "${ised_ops[@]}"

    # Fix up package buildfile(s).
    #
    # Replace '-' with '_' in lib{} target names. Necessary because the
    # convention seems to be to use underscores in the filenames of the Boost
    # library binaries. For example:
    #
    #   lib{boost-callable-traits} -> lib{boost_callable_traits}
    #
    # Use the fact that we have most of the underscored version in `un` to
    # simplify the `sed` script.
    #
    ss="s%lib\{${pn#lib}\}%lib\{boost_$un\}%g" # Sed script.
    ised "$lib_bfile"                 -e "$ss"
    ised "$pn/tests/basics/buildfile" -e "$ss"

    # Add dependencies to the package manifest and the library buildfile.
    #
    add_deps "$pn/manifest" "$lib_bfile" "${intf_deps[$pn]}" "intf_libs"
    add_deps "$pn/manifest" "$lib_bfile" "${impl_deps[$pn]}" "impl_libs"

    # Create smoke test (by modifying the test generated by `bdep-new`).
    #
    # For now we just include the library's header(s) from the test driver's
    # source file and, if it compiles, we could not have missed any
    # headers. (But while developing, remember to ensure that your system
    # Boost installation isn't masking breakages.)
    #

    # Build the include directive(s) appropriate for this library. If it
    # exists, include only the super-header (a single header which includes
    # all of its headers), otherwise include all headers in
    # `boost/include/<lib>/` and `boost/include/`.
    #
    # Based on inspection, the informal convention seems to be that Boost
    # libraries should provide super-headers and that it should be located
    # either at `include/boost/<lib>.hpp` or
    # `include/boost/<lib>/<lib>.hpp`. Only a minority of libraries do not
    # conform. (If there were a formal convention I would expect it to be
    # referenced by https://www.boost.org/development/requirements.html.)
    #
    # For reference, here are some of the non-conforming libraries and the
    # ways in which they break the convention:
    #
    #   - Libraries with con-conforming super-header names: Exception
    #     (`include/boost/exception/all.hpp`)
    #
    #   - Libraries that put non-super header(s) under `include/boost/`:
    #     Conversion, Iterator, Unordered, Math, Core, Multi-Index, ...
    #
    #   - Libraries that have what looks like a super-header but which doesn't
    #     actually include all of its headers: Utility
    #
    incl= # The include statement(s).
    if [[ -f "$pn/include/boost/$udn.$he" ]]; then
      incl="#include <boost/$udn.$he>"$'\n'
    elif [[ -f "$pn/include/boost/$udn/$udn.$he" ]]; then
      incl="#include <boost/$udn/$udn.$he>"$'\n'
    else
      # No super-header found, so include all headers directly under
      # `include/boost/` and `include/boost/<lib>/`.
      #
      for h in "$udp/include/boost/"*."$he"; do
        incl+="#include <boost/$(basename "$h")>"$'\n'
      done
      for h in "$udp/include/boost/$udn/"*."$he"; do
        incl+="#include <boost/$udn/$(basename "$h")>"$'\n'
      done
    fi

    # Generate the test driver source file.
    #
    cat <<EOF > "$pn/tests/basics/driver.$se"
$incl
int
main ()
{
  return 0;
}
EOF
  done

  ((++level))
done

# Modify the root buildfile to exclude the upstream directory and those
# packages which build configuration set differs from the default class set
# (see the override file for deviations).
#
# Note that we could probably exclude only the packages that are not buildable
# on Linux (our development OS). Let's, however, not complicate things for now
# and reuse the manifest_builds override.
#
exclusions=
for p in "${!manifest_builds[@]}"; do # p: build2 package name.
  exclusions+='\\\n'"                  -$p/"
done

ised buildfile -e "s%(import pkgs =) \*/%\1 \{*/ -upstream/$exclusions\}%"

# Remove commented-out and empty lines from `repositories.manifest`.
#
ised repositories.manifest -e "/(^#|^$)/d"
