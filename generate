#!/usr/bin/env bash

# file      : generate
# license   : Boost Software License 1.0; see accompanying LICENSE file

# Create build2 packages for the Boost C++ libraries.
#
# Use the official Boost superproject repository at
# https://github.com/boostorg/boost as source. Generate bpkg git repository
# containing Boost C++ library packages.
#
# --version-suffix <suffix>
#
#   A suffix to be added to the Boost version while deriving the library
#   packages version, or empty to use the Boost version unmodified. If this
#   option is omitted a suffix of "-a.0.z" will be used.
#
# --clean-upstream
#
#   Clean up the upstream tree by removing files and directories we do not
#   need, then exit.
#

# Issues:
#
# - Looking at
#   https://ci.stage.build2.org/@51f8c2d3-f6a0-423f-bb8c-e42b65781a53 you can
#   see a number of aborted Windows build tasks. At least some of them are due
#   to build timeout (something hanged or executes to slowly). If this happen
#   again during some future CI we need to investigate this. For that purpose
#   you can try to use the recently implemented interactive CI mode. See
#   bdep-ci man page for more details.
#

owd="$(pwd)"
trap "{ cd '$owd'; exit 1; }" ERR
set -o errtrace     # Trap in functions and subshells.
set -o pipefail     # Fail if any pipeline command fails.
shopt -s lastpipe   # Execute last pipeline command in the current shell.
shopt -s nullglob   # Expand no-match globs to nothing rather than themselves.

function info () { echo "$*" 1>&2; }
function error () { info "$*"; exit 1; }

# A suffix to be applied to the Boost version in the `version` package
# manifest field. (See the `--version-suffix` option above.)
#
version_suffix="-a.0.z"

# If true, remove files and directories we do not need from `upstream/`.
#
clean_upstream=

while [[ "$#" -gt 0 ]]; do
  case "$1" in
    --version-suffix)
      shift
      version_suffix="$1"
      shift || true
      ;;
    --clean-upstream)
      shift
      clean_upstream=true
      ;;
    -*)
      error "unknown option: $1"
      ;;
    # End of options.
    #
    *)
      error "unexpected '$1'"
      break
      ;;
  esac
done

# Print "true" to stdout if <target> matches, case-insensitively, any of the
# subsequent words (patterns).
#
function match_patterns () # <target> <patt0> <patt1> ...
{
  local t="$1" # Target.
  shift

  shopt -s nocasematch
  local p # Pattern.
  for p in "$@"; do
    if [[ "$t" == $p ]]; then
      echo "true"
      break
    fi
  done
  shopt -u nocasematch
}

# Clean the upstream tree if we were asked to.
#
# NOTE: if the list of library-specific removals becomes too long, we will
# probably move them into a "removals file".
#
if [[ "$clean_upstream" ]]; then

  # Clean `upstream/`.
  #
  # The `keep` array contains patterns matching paths not to be removed
  # (case-insensitively).
  #
  # Keep `upstream/Jamroot` because `boostdep` checks for its existence in
  # order to decide whether `upstream` is a valid Boost root directory.
  #
  # Use a pattern for the license because the root license has the license
  # version in the filename and there is no consistent naming format among
  # libraries.
  #
  # Turn on `dotglob` so that files beginning with `.` will be included in
  # pathname expansions (without explicitly matching them with `.*`), and `.`
  # and `..` will be excluded.
  #
  shopt -s dotglob
  keep=("Jamroot" "libs" "tools" "LICENSE*" ".gitattributes")
  for p in upstream/*; do # p: path.
    if [[ ! "$(match_patterns "${p#upstream/}" "${keep[@]}")" ]]; then
      rm -rf "$p"
    fi
  done

  # Clean `upstream/tools/`.
  #
  keep=("boostdep")
  for p in upstream/tools/*; do # p: path.
    if [[ ! "$(match_patterns ${p#upstream/tools/} "${keep[@]}")" ]]; then
      rm -rf "$p"
    fi
  done

  # Clean `upstream/libs/*/`.
  #
  # Keep `upstream/libs/*/sublibs` otherwise `boostdep` will skip libraries
  # that are not directly under `upstream/libs/` which will affect its
  # dependency graphs (see below for examples of sublibs).
  #
  # Keep `tool*` and `check*` because some of those contain files that might
  # be useful in future (and they take up little space).
  #
  # Use a pattern for README because there is no consistent naming format
  # among libraries.
  #
  # While most libraries have their Jamfiles in `build/`, some have them in
  # their root directories.
  #
  keep=("include" "src" "meta" "build" "config" "sublibs"
        "LICENSE*" "README*"
        ".gitattributes"
        "tool*" "check*"
        "cmake*" "Jamfile*")

  # Sublibs: libraries that are not directly under `upstream/libs/`.
  #
  sublibs=("algorithm/string" "algorithm/minmax"
           "numeric/ublas" "numeric/odeint"
           "numeric/interval" "numeric/conversion")

  for l in upstream/libs/*; do  # l: library.
    for p in "$l/"*; do # p: path.
      # If `p` is not a sublib, then remove as usual if appropriate.
      #
      if [[ ! "$(match_patterns ${p#upstream/libs/} "${sublibs[@]}")" ]]; then
        if [[ ! "$(match_patterns ${p#$l/} "${keep[@]}")" ]]; then
          rm -rf "$p"
        fi
      # Otherwise (`p` is a sublib) clean its directory as well.
      #
      else
        for p2 in "$p/"*; do # p2: path within sublib `p`.
          if [[ ! "$(match_patterns ${p2#$p/} "${keep[@]}")" ]]; then
            rm -rf "$p2"
          fi
        done
      fi
    done
  done
  shopt -u dotglob

  # Remove library-specific files.
  #
  # None yet.
  #

  info "cleaned upstream/"
  exit 0
fi

# Get the Boost version from upstream/. See the root README for more info.
#
r="$(sed -n -Ee "s%^#\s*define\s+BOOST_VERSION\s+([0-9]+)%\1%p" \
         upstream/libs/config/include/boost/version.hpp)"

# At this point `r` will have a value like `107501` for Boost release 1.75.1.
# (The following arithmetic is specified in
# upstream/libs/config/include/boost/version.hpp.)
#
boostver="$(($r / 100000)).$((($r / 100) % 1000)).$(($r % 100))"

# Remove files/directories about to be generated, if they already exist.
#
rm -rf .gitignore .gitattributes \
       .bdep buildfile repositories.manifest packages.manifest \
       levels dependencies boostdep libboost-*

# Compile boostdep.
#
# Note that here we rely on the boost_filesystem library of a suitable version
# to be installed into the system. Building boostdep only using source files
# in the upstream/ directory feels too complicated at the moment since
# boost-filesystem has quite a lot of dependencies.
#
c++ -o boostdep upstream/tools/boostdep/src/boostdep.cpp -lboost_filesystem

# Produce the library dependency levels file.
#
# Libraries at a given dependency level depend only on libraries at lower
# levels. So those at level 0 have no dependencies while those at level 2
# depend only on libraries at levels 0 and/or 1, and so on.
#
# Use `boostdep` to group the Boost libraries by dependency level and parse
# that output into our own format which we write to a file named `levels`.
#
# The output produced by `boostdep` looks like this:
#
#   Module Levels:
#
#   Level 0:
#       (unknown)
#       callable_traits
#       compatibility
#       config
#       ...
#
#   Level 1:
#       assert -> config(0)
#       io -> config(0)
#       ...
#
#   Level 2:
#       core -> assert(1) config(0)
#       ...
#   ...
#
# A tilde (~) in the library name means a directory separator, for example,
# numeric~conversion. See README-DEV for an explanation of the "(unknown)"
# dependency.
#
# Our output file, `levels`, contains one dependency level's libraries per
# line, starting at level 0, with each level's libraries separated by spaces,
# like this:
#
#   callable_traits compatibility config hof
#   assert io polygon static_assert
#   core stl_interfaces system throw_exception type_traits
#
sep=
./boostdep --boost-root upstream \
           --track-sources \
           --module-levels | while read line; do

  # If we're at a new, non-zero dependency level then begin a new line of
  # output.
  #
  if [[ "$line" == "Level "[1-9]* ]]; then
    echo
    sep=

  # 1. Match lines like "<libname> -> <dep0> <dep1>...\n" (which are libraries
  #    at a non-zero level).
  #
  # 2. Skip the "(unknown)\n" line.
  #
  # 3. Match (non-empty) lines that do not contain any colons, thus matching
  #    lines like "<libname>\n" (which are libraries at level 0), but skipping
  #    the "Module Levels:\n" and "Level 0:\n" lines.
  #
  elif [[ ("$line" =~ (.+)" -> ") ||
          (("$line" != "(unknown)") && ("$line" =~ (^[^:]+$))) ]]; then
    echo -n "$sep${BASH_REMATCH[1]}"
    sep=' '
  fi
done > levels

echo >> levels # Terminate the last line.

# Convert a library name in `boostdep` format (see above) to a build2 package
# name and write it to stdout.
#
# The build2 package name is derived from the `boostdep` name by prefixing it
# with "libboost-" and replacing all underscores and tildes with hyphens. For
# example:
#
#   compatibility    -> libboost-compatibility
#   callable_traits  -> libboost-callable-traits
#   numeric~interval -> libboost-numeric-interval
#
# This script uses this format (which we will call "our") everywhere with a
# few exceptions: the `levels` and `dependencies` files and the values (not
# keys) in the `intf_deps` and `impl_deps` associative arrays, in both of
# which cases we keep the original; and library build target names where, for
# compatibility with system-installed library names, we use what is
# essentially the upstream name (see `upstream_name()`).
#
function pkg_name () # <library-name>
{
  echo "libboost-$(sed -Ee "s%[~_]%-%g" <<<"$1")"
}

# Convert a library name in `boostdep` format (see above) to an upstream
# library name and write it to stdout.
#
# In the majority of cases the upstream library name is identical to the
# `boostdep` name, except for those few libraries whose directories are not
# directly under `upstream/libs/`, in which cases `boostdep`'s tildes are
# replaced with underscores. For example:
#
#   numeric~foo_bar -> numeric_foo_bar
#
# Note that all of the libraries under `upstream/libs/numeric/` will be given
# this "numeric_" prefix whereas the Boost project only applies it to
# `numeric/conversion` (for example, they use just `ublas` and
# `interval`). But our way is more consistent and works out simpler for our
# purposes (they are header-only so there is no issues with binary library
# names). Because this divergence is limited to a tiny minority of libraries,
# "upstream_name" is still considered to be an appropriate name for this
# function.
#
function upstream_name () # <library-name>
{
  echo "$(sed -Ee "s%~%_%g" <<<"$1")"
}

# Read the library exclusions list from the file named `exclude` into the
# `lib_excl` associative array.
#
# This file contains one library/package name per line, in our format. For
# example:
#
#   libboost-callable-traits
#   libboost-compatibility
#   libboost-numeric-interval
#
declare -A lib_excl=()
cat exclude | while read line; do
  # Skip comments and empty lines.
  #
  if [[ -n "$line" && "$line" != "#"* ]]; then
    lib_excl["$line"]=true
  fi
done

# Create an empty build2 project in the root directory.
#
bdep new --type empty

# Append, to the new .gitignore, generated files that are not to be checked
# in. (`.gitignore` was just generated by `bdep new` above.)
#
cat << EOF >> .gitignore

# The generated files.
#
/boostdep

# Intermediate files.
#
*.bak
EOF

# Edit a file in-place with `sed` in the extended regex mode.
#
# Additional `sed` options may be passed after <file-path>.
#
function ised () # <file-path> <sed-option>...
{
  local f="$1"                  # File path.
  shift
  local o=("$@")                # Options to pass to `sed`.

  # `sed -i<backup-extension>` is not in POSIX but works on Linux, the BSDs,
  #  and Mac OS. The extension is optional on Linux but not the BSDs so must
  #  be provided.
  #
  sed -E -i.bak "${o[@]}" "$f"
  rm -f "$f.bak"
}

# Load various overrides from the override file. See this file for the
# overrides semantics.
#
declare -A manifest_url=()
declare -A manifest_builds=()
declare -A binless_libs=()
declare -A cxx_only=()
declare -A source_macro=()
declare -A nonboost_intf_deps=()
declare -A nonboost_impl_deps=()
declare -A include_headers=()
declare -A exclude_headers=()
declare -A exclude_dependencies=()
source override

# The Boost version, but formatted for use in the `doc-url` package manifest
# field. This is just `boostver` with everything but the major, minor, and
# patch components removed and all '.' replaced with '_'. For example,
# "1.75.1.beta1" -> "1_75_1". Note that Boost doesn't publish documentation
# for pre-releases.
#
doc_url_ver="$(sed -E -e "s%^([0-9]+\.[0-9]+\.[0-9]+).*%\1%" \
                      -e "s%\.%_%g" \
                      <<<"$boostver")"

# Detect the language of an upstream Boost library.
#
# Return, by writing to stdout, the `bdep-new` options that specify the
# primary and, potentially, secondary languages (to be passed to its `--lang`
# option; for example, "c++,c").
#
# This function is based on the observation that Boost is a collection of C++
# libraries and therefore C++ headers take priority in determining the primary
# language. Thus a library is only a C library if all of its public headers
# are C headers.
#
# All of a Boost library's source files reside in `src/` (see
# https://www.boost.org/development/requirements.html#Organization) so if
# there is no such directory then a library has no source files.
#
function detect_lang () # <lib-dir-path> <binful>
{
  local d="$1"  # Upstream library directory path.
  local bf="$2" # True if this library is binful.

  local r

  # If there are any public C++ headers then the primary language is C++,
  # otherwise it's C.
  #
  # Pass `-maxdepth` to `find` in order to prevent the search for C++ headers
  # from descending below `include/boost/<lib>/` otherwise it would return
  # private headers, in which case a C library with a single private C++
  # header would be detected as a C++ library. (This `find` option is not in
  # POSIX but is supported on Linux, the BSDs, and Mac OS.)
  #

  # The value of the `-maxdepth` option to `find`. Increase it if the upstream
  # directory path is not directly under `upstream/libs/` (that is, it has
  # more than two slashes (for example, `upstream/libs/numeric/conversion`).
  #
  local md=2
  if [[ "$d" == "upstream/libs/"*"/"* ]]; then
    md=3
  fi

  local hsp="$d/include/boost" # Header search path.
  if [[ -n "$(find "$hsp" -maxdepth "$md" -type f -name "*.hpp")" ]]; then
    r="c++"

    # If there are any C headers (public or private) or C source files then
    # the secondary language is C.
    #
    if [[ -n "$(find "$hsp" -type f -name "*.h")" ||
          ("$bf" && -n "$(find "$d/src" -type f -name "*.c")") ]]; then
      r+=",c"
    fi
  else
    r="c"

    info "warning: detected $pn to be a C library"

    # If there are any C++ source files then the secondary language is
    # C++.
    #
    if [[ "$bf" && -n "$(find "$d/src" -type f -name "*.cpp")" ]]; then
      r+=",c++"
    fi
  fi

  echo "$r"
}

# Determine the dependencies between Boost libraries. Create a mapping from
# each Boost library to the other Boost libraries it depends on.
#
# `boostdep --module-overview` outputs the dependencies (other Boost libraries
#  only) of each Boost library in the following format (dependent to the left
#  and dependencies to the right of the arrow):
#
#    ...
#    align -> assert config core static_assert
#    any -> config core static_assert throw_exception type_index type_traits
#    array -> assert config core static_assert throw_exception
#    ...
#
# Note that `boostdep` sorts the dependent and dependency library names
# alphabetically (a fact that we take advantage of later).
#
# By default `boostdep` searches only header files for include statements
# (that is, it outputs only interface dependencies) but it will also search
# source files if the `--track-sources` flag is passed and thus we can get it
# to additionally include implementation dependencies in the output.
#
# Classify dependencies as interface or implementation by first outputting the
# interface dependencies only and storing those in `intf_deps`, an associative
# array indexed by the build2 package name and with values taken directly from
# the right-hand side of the arrow in the `boostdep` output above. For
# example:
#
#   ...
#   [libboost-align]="assert config core static_assert"
#   [libboost-any]="config core static_assert throw_exception..."
#   [libboost-array]="assert config core static_assert throw_exception"
#   ...
#
# Then run `boostdep` again, this time including implementation dependencies
# in the output. For each dependency, if it is already in `intf_deps` then its
# interface dependency status takes precedence; otherwise it is an
# implementation(-only) dependency and is added to the `impl_deps` associative
# array (which has the same structure as `intf_deps`).
#
# Also write each library's interface and implementation dependencies to a
# file called `dependencies` to be put under version control in order to alert
# us to dependency changes.
#
# The file has two lines for each library: the first for its interface
# dependencies and the second for its implementation dependencies. Each line
# begins with the library name followed by a colon and, if there are
# dependencies of that type, a space followed by the space-separated list of
# dependencies. The lines are sorted alphabetically by library name. All
# library names are in the `boostdep` format. For example:
#
#   ...
#   assert: config
#   assert:
#   assign: array config core move mpl preprocessor...
#   assign:
#   atomic: assert config static_assert type_traits winapi
#   atomic: align predef preprocessor
#   ...
#
# This format was designed for line-based diffs.
#
declare -A intf_deps=() # Interface dependencies for all libraries.
declare -A impl_deps=() # Implementation dependencies for all libraries.

# Gather interface dependencies for all libraries.
#
./boostdep --boost-root upstream \
           --module-overview | while read line; do
  if [[ "$line" =~ (.+)" -> "(.+) && -n "${BASH_REMATCH[2]}" ]]; then
    pn="$(pkg_name ${BASH_REMATCH[1]})" # build2 package name.

    # Remove the "(unknown)" dependency using the Bash pattern substitution
    # parameter expansion form.
    #
    # Note that we add the leading space to ease serialization into the
    # dependencies file (see below).
    #
    intf_deps["$pn"]=" ${BASH_REMATCH[2]/(unknown) /}"
  fi
done

# Print "true" to stdout if <target> equals any of the subsequent
# arguments/words.
#
function contains () # <target> <word0> <word1> ...
{
  local t="$1"
  shift

  local w
  for w in "$@"; do
    if [[ "$w" == "$t" ]]; then
      echo -n "true"
      return
    fi
  done
}

# Return the set difference of <A> and <B>. That is, every element in <A> that
# is not also an element of <B>. <A> and <B> are strings consisting of each
# set's space-separated elements.
#
function difference () # <A> <B>
{
  local a=($1)
  local b=($2)

  local i
  for i in "${!a[@]}"; do
    if [[ "$(contains "${a[$i]}" "${b[@]}")" ]]; then
      unset "a[$i]"
    fi
  done

  echo "${a[@]}"
}

# Gather implementation dependencies for all libraries.
#
# Also write the `dependencies` file in this loop in order to take advantage
# of the fact that the dependent library names are already sorted
# alphabetically in `boostdep`'s output.
#
# Note that --track-sources must be specified before --module-overview.
#
./boostdep --boost-root upstream \
           --track-sources \
           --module-overview | while read line; do
  if [[ "$line" =~ (.+)" -> "(.+) ]]; then
    lib="${BASH_REMATCH[1]}"  # Library name in `boostdep` format.
    deps="${BASH_REMATCH[2]}" # Library dependencies.
    pn="$(pkg_name $lib)"     # build2 package name.

    # Save the implementation dependencies in `impl_deps`, if any.
    #
    # Exclude the "(unknown)" dependency and all interface dependencies,
    # leaving only the implementation dependencies.
    #
    r="$(difference "$deps" "(unknown) ${intf_deps[$pn]}")"
    if [[ -n "$r" ]]; then
      impl_deps["$pn"]=" $r"
    fi

    # Now that we have all interface and all implementation dependencies for
    # this library, append them to the `dependencies` file.
    #
    echo "$lib:${intf_deps[$pn]}" >> dependencies
    echo "$lib:${impl_deps[$pn]}" >> dependencies

  elif [[ -n "$line" && ! ("$line" =~ ':'$) ]]; then
    # This is a library with no dependencies (this line is neither empty, nor
    # does it end with a colon, nor does it contain an arrow; so it is neither
    # the report heading or the blank line following it, nor a library with
    # dependencies). Write empty interface and implementation dependencies
    # entries, so if it gets dependencies on upgrade we could easily
    # distinguish it from a new library using git diff.
    #
    echo "$line:"$'\n'"$line:" >> dependencies
  fi
done

# Add dependencies to a library's package manifest and buildfiles.
#
# The <manifest> and <buildfile> arguments are the paths to the files to
# edit.
#
# The <deps> argument is a space-separated list of the package's dependencies
# either in the `boostdep` name format or in the Buildfile project-qualified
# target format with an optional package version constraint appended. For
# example:
#
#   atomic
#   filesystem
#   numeric~ublas
#   libicuuc%lib{icuuc}^65.1.0
#   libicuuc%lib{icudata}
#   libicui18n%lib{icui18n}==65.1.0
#
# See the `override` file for more information.
#
# The <bf-var> argument is the name of the buildfile variable to modify:
# either "intf_libs" or "impl_libs".
#
function add_deps () # <manifest> <buildfile> <deps> <bf-var>
{
  local mf="$1"   # Path to the manifest.
  local bf="$2"   # Path to the buildfile.
  local deps=($3) # Dependencies.
  local vn="$4"   # Buildfile variable name.

  # Build a list of editing scripts for each file, then pass them all at once
  # to `sed`, thus invoking it only once per file.
  #
  local mscr=()     # Sed scripts for the package manifest.
  local bscr=()     # Sed scripts for the library buildfile.
  local -A mdeps=() # Dependency project names already added to the manifest.

  local i
  for i in "${!deps[@]}"; do
    local d="${deps[$i]}" # Dependency.

    local dpn= # Dependency package name.
    local dln= # Dependency library name.
    local dvc= # Dependency version constraint.

    if [[ "$d" =~ ^(.+)'%lib{'(.+)'}'(.+)?$ ]]; then
      # Dependency is in project-qualified target format.
      #
      dpn="${BASH_REMATCH[1]}"
      dln="${BASH_REMATCH[2]}"

      if [[ -n "${BASH_REMATCH[3]}" ]]; then # Is version constraint present?
        # Insert a space before the version constraint operator and, if it's a
        # comparison operator, also after it. (Ranges are not supported.)
        #
        dvc=" $(sed -Ee "s%(==|<|<=|>|>=)%\1 %" <<<"${BASH_REMATCH[3]}")"
      fi
    else
      # Dependency is in `boostdep` name format.
      #
      dpn="$(pkg_name "$d")"
      dln="boost_$(upstream_name "$d")"
      dvc=" == $"
    fi

    # Append the current dependency to the package manifest in a new line
    # unless it's already been added (in which case <deps> contains multiple
    # targets from the same project/package).
    #
    if [[ ! "${mdeps[$dpn]}" ]]; then
      mscr+=(-e "/^depends: \* bpkg/a\\
depends: $dpn$dvc")

      mdeps["$dpn"]=true
    fi

    # Update the "(intf|impl)_libs = ..." Buildfile variable with the current
    # dependency.
    #
    # @@ TODO: make this conditional if the dependency is only required under
    #    some circumstances. For example, if a library only builds on Windows
    #    then do not depend on it if on Linux. Maybe we can reuse the
    #    manifest_builds overrides for that somehow? We also still lack the
    #    corresponding mechanism in manifest (conditional dependencies).
    #
    #    Currently the only problem case is Boost.WinApi, a header-only
    #    library that can only be used on Windows. All of its dependents we've
    #    examined thus far only include its headers if on Windows and thus
    #    they can all be built on non-Windows platforms despite their
    #    (redundant) dependence on Boost.WinApi. So this is no showstopper.
    #
    #    Therefore we're deferring dealing with conditional dependencies until
    #    another, more pressing case arises.
    #
    local dt="$dpn%lib\{$dln\}" # Dependency text.
    if [[ "$i" -eq 0 ]]; then # First dependency: initialize variable.
      local a=" = " # The formatted assignment operator.
      if [[ "${#deps[@]}" -gt 1 ]]; then
        a="  = " # More deps coming, so adjust to align with " += "
      fi
      bscr+=(-e "s/^$vn = #.*/import $vn$a$dt/")
    else # Subsequent dependencies: update/append to variable.
      bscr+=(-e "/^import $vn.*/a\\
import $vn += $dt")
    fi
  done

  # Edit the files if there are dependencies.
  #
  if [[ "${#deps[@]}" -ne 0 ]]; then
    ised "$mf" "${mscr[@]}"
    ised "$bf" "${bscr[@]}"
  fi
}

# Generate a build2 project/package for each Boost library and add them as
# packages to the root project.
#
# Do one dependency level at a time, starting at level 0.
#
# @@ Package manifest values yet to be customized:
#
#    - email: currently using boost-users@boost.org but we'll probably be
#      switching to the maintainer email addresses in
#      upstream/libs/<lib>/meta/libraries.json.
#
cat levels | while read line; do
  libs=($line) # The libraries at the current dependency level.

  # Create a build2 project for each library at the current dependency level.
  #
  # Note that `lib` is the `boostdep` library name (see above).
  #
  for lib in "${libs[@]}"; do
    udn="$(sed -Ee "s%~%/%g" <<<"$lib")" # Upstream directory name.
    udp="upstream/libs/$udn"             # Upstream directory path.
    un="$(upstream_name "$lib")"         # Upstream library name.
    pn="$(pkg_name "$lib")"              # build2 package name.

    # Skip this library if it's in the exclusion list.
    #
    if [[ -v "lib_excl[$pn]" ]]; then
      info "skipping $pn (excluded)"
      continue
    fi

    # Detect binless libraries.
    #
    binful= # True if this is a binful libary.
    if [[ -d "$udp/src" && ! -v "binless_libs[$pn]" ]]; then
      binful=true
    fi

    # Configure language-specific settings.
    #
    he= # Header file extension.
    se= # Source file extension.

    # Suboptions to the `bdep-new` `--lang` option. Start off with the primary
    # and, if applicable, secondary language suboptions. For example, "c++,c".
    #
    # Override the language to C++ if necessary (see the `override` file).
    #
    if [[ "${cxx_only[$pn]}" ]]; then
      lo="c++"
    else
      lo="$(detect_lang "$udp" "$binful")"
    fi

    case "$lo" in
      # Primary language is C++.
      #
      c++*)
        he="hpp"
        se="cpp"
        ;;
      # Primary language is C.
      #
      *)
        he="h"
        se="c"
        ;;
    esac

    # Specify the C++ header and source extensions if this library has C++ as
    # primary or secondary language.
    #
    if [[ "$lo" == *"c++"* ]]; then
      lo+=",hxx=hpp,cxx=cpp,ixx=ipp,txx=tpp"
    fi

    # Suboptions to `bdep-new` `--type` option.
    #
    # With these prefix and subdir options the include directory is
    # `include/boost/` and the source directory `src/` (mirroring upstream).
    #
    to="lib,split,subdir=boost,no-subdir-source,no-version"

    # Set the location of the library buildfile based on whether this library
    # is binful or not.
    #
    lib_bfile= # Library buildfile (the one that declares the library target).
    if [[ "$binful" ]]; then
      lib_bfile="$pn/src/buildfile"
    else
      lib_bfile="$pn/include/boost/buildfile"
      to+=",binless"
    fi

    # Create a build2 project for the current library, adding it as a package
    # to the root project.
    #
    # Let's create the LICENSE file prior to creating the package, so that
    # bdep-new can pick it up (detect the license manifest value, add it to
    # the buildfile, etc).
    #
    # @@ Shouldn't we be linking to each library's own license?. Some
    #    libraries have different licenses. E.g. some have MIT, some have
    #    combined licenses, and some add copyright lines to the top of the
    #    standard BOOST license.
    #
    mkdir "$pn"
    ln -s "../LICENSE" "$pn"

    # Add upstream's README.md, if present, to the project.
    #
    # Note that bdep-new doesn't recognize Boost's README.md format and issues
    # the warning. Thus, we replace the generated file after it is created.
    #
    # @@ Libraries use various cases and extensions for their READMEs so
    #    perhaps we should use a pattern here?
    #
    if [[ ! -f "$udp/README.md" ]]; then
      to+=",no-readme"
    fi

    bdep new --package --lang "$lo" --type "$to" "$pn"

    if [[ -f "$pn/README.md" ]]; then
      ln -sf "../$udp/README.md" "$pn"
    fi

    # Remove the bdep-generated header.
    #
    rm "$pn/include/boost/${pn#lib}.$he"

    # Create symlinks to the upstream headers inside the new project
    # directory.
    #
    for f in "$udp/include/boost/"*; do
      ln -s "../../../$f" "$pn/include/boost/"
    done

    # If this is a binful library, remove the `bdep-new`-generated source file
    # and export header and create symlinks to the upstream source files.
    #
    if [[ "$binful" ]]; then
      rm "$pn/src/${pn#lib}.$se"
      rm "$pn/include/boost/export.$he"

      for f in "$udp/src/"*; do
        ln -s "../../$f" "$pn/src/"
      done
    fi

    # Derive the project url package manifest value (see the override file for
    # deviations).
    #
    if [[ -v "manifest_url[$pn]" ]]; then
      url="${manifest_url[$pn]}"
    else
      url="https://github.com/boostorg/$un"
    fi

    # The `doc-url` package manifest field, which refers to the documentation
    # for the packaged (not latest) version of the current library. Note that,
    # unlike the GitHub URL, the project name component of the documentation
    # URL is the upstream directory name instead of the upstream library
    # name. For example:
    #
    #   https://www.boost.org/doc/libs/1_75_1/libs/numeric/ublas
    #
    doc_url="https://www.boost.org/doc/libs/$doc_url_ver/libs/$udn"

    ised_ops=(\
      -e "s%^(version:).+%\1 $boostver$version_suffix%" \
      -e "s%^(url:).+%\1 $url%" \
      -e "/^url:/a\\
doc-url: $doc_url" \
      -e "s%^(email:).+%\1 boost-users@lists.boost.org  ; Mailing list.%" \
      -e "s%^#(build-error-email:).+%\1 builds@build2.org%" \
      -e "/^#depends:/d" \
      -e "/^license:/a\\
topics: C++, Boost" \
      -e "/^url:/a\\
package-url: https://github.com/build2-packaging/boost" \
      -e "/^email:/a\\
package-email: packaging@build2.org ; Mailing list.")

    # The `builds` package manifest value. Set to the default value unless
    # overridden for this library (see the override file).
    #
    if [[ -v "manifest_builds[$pn]" ]]; then
      ised_ops+=(-e "/build-error-email/a\\
builds: ${manifest_builds[$pn]}")
    else
      ised_ops+=(-e '/build-error-email/a\
builds: default\
builds: -( +macos &gcc ) ; https://github.com/boostorg/config/issues/399')
    fi

    # Fix up the package manifest.
    #
    ised "$pn/manifest" "${ised_ops[@]}"

    # If this library has any custom buildfiles, copy them over the
    # bdep-generated ones (before we modify them).
    #
    # Note that we don't symlink these files since we will edit the copy.
    #
    f="downstream/libs/$udn/src/buildfile"
    if [[ -f "$f" ]]; then
      cp "$f" "$pn/src/"
    fi

    f="downstream/libs/$udn/include/boost/buildfile"
    if [[ -f "$f" ]]; then
      cp "$f" "$pn/include/boost/"
    fi

    # Fix up package buildfile(s).
    #
    # Replace '-' with '_' in lib{}, liba{}, and libs{} target
    # names. Necessary because the convention seems to be to use underscores
    # in the filenames of the Boost library binaries. For example:
    #
    #   lib{boost-callable-traits} -> lib{boost_callable_traits}
    #
    # Use the fact that we have most of the underscored version in `un` to
    # simplify the `sed` script.
    #
    ss="s%lib(a|s)?\{${pn#lib}\}%lib\1\{boost_$un\}%g" # Sed script.
    ised "$lib_bfile"                 -e "$ss"
    ised "$pn/tests/basics/buildfile" -e "$ss"

    # Remove the reference to the `bdep-new`-generated export header from the
    # include directory's buildfile if this is a binful library.
    #
    # @@ TODO: maybe add bdep-new no-export sub-option?
    #
    if [[ "$binful" ]]; then
      ised "$pn/include/boost/buildfile" -e "/hxx\{export\}/,/^$/d"
    fi

    # Deduplicate interface dependencies (across the entire dependency graph,
    # not just this library's direct dependencies) if there are any.
    #
    if [[ "${#intf_deps[$pn]}" -ne 0 ]]; then
      ised "$lib_bfile" -e '/#import xxxx_libs/a\
\
intf_libs = $cxx.deduplicate_export_libs($intf_libs)'
    fi

    # Remove dependencies that were manually excluded.
    #
    intf_deps["$pn"]="$(difference "${intf_deps[$pn]}" \
                                   "${exclude_dependencies[$pn]}")"
    impl_deps["$pn"]="$(difference "${impl_deps[$pn]}" \
                                   "${exclude_dependencies[$pn]}")"

    # Add dependencies to the package manifest and the library buildfile.
    #
    add_deps "$pn/manifest" "$lib_bfile" \
             "${nonboost_intf_deps[$pn]} ${intf_deps[$pn]}" \
             "intf_libs"
    add_deps "$pn/manifest" "$lib_bfile" \
             "${nonboost_impl_deps[$pn]} ${impl_deps[$pn]}" \
             "impl_libs"

    # Make a number of changes to the library buildfile in a batch.
    #
    # Remove the '#import xxxx_libs += libhello%lib{hello}' line from the
    # library buildfile.
    #
    ised_ops=(-e "/\#import xxxx_libs.+/d")

    # Define some linking-related macros in the library buildfile if this is a
    # binful library.
    #
    # Note that, in the comments below, "export" refers to build2's library
    # exportation features, and applies only to macros. References to the
    # exportation of symbols from compiled libraries will be qualified with
    # "symbol", for example "symbol exporting code".
    #
    if [[ "$binful" ]]; then
      # Determine the build2 language module. Note that `lo` is likely to
      # contain more than just the primary and secondary language suboptions.
      #
      case "$lo" in
        c++,c*|c,c++*) mod="cc"  ;;
        c++*)          mod="cxx" ;;
        *)             mod="c"   ;;
      esac

      # BOOST_<lib>_NO_LIB:      Disable auto-linking of this library.
      #                          Naturally this macro is for export only.
      #
      #                          See https://en.wikipedia.org/wiki/Auto-linking,
      #                          https://www.boost.org/doc/libs/1_75_0/libs/config/doc/html/boost_config/boost_macro_reference.html,
      #                          and
      #                          `upstream/libs/config/include/boost/config/auto_link.hpp`
      #                          for more information.
      #
      # BOOST_<lib>_DYN_LINK:    Needs to be defined when compiling the library
      #                          as a shared library and undefined when
      #                          compiling it as a static library. Its primary
      #                          purpose seems to be to enable the symbol
      #                          exporting/importing code. This macro must be
      #                          exported for shared library targets.
      #
      # BOOST_<lib>_STATIC_LINK: Needs to be defined when compiling the
      #                          library as a static library and undefined
      #                          when compiling it as a shared library. This
      #                          macro is not conventional and is actually
      #                          redundant in light of the semantics of
      #                          BOOST_<lib>_DYN_LINK, but it is used by some
      #                          libraries so define it (as appropriate) just
      #                          in case. Export this macro for static
      #                          library targets.
      #
      # BOOST_<lib>_SOURCE:      If defined (along with BOOST_<lib>_DYN_LINK),
      #                          symbols tagged with the BOOST_<lib>_DECL
      #                          macro are exported, otherwise they are
      #                          imported (if the toolchain supports these
      #                          concepts). This macro is only used for
      #                          building a library and must not be exported.
      #
      umn="${un^^}" # Upstream name for C macros (upstream name in uppercase).

      # Define `BOOST_<lib>_SOURCE` on obj{} targets if required for this
      # library (see the `override` file for details).
      #
      if [[ "${source_macro[$pn]}" ]]; then
        ised_ops+=(-e "/.+ -DBOOST_STATIC_BUILD$/\
i{hbmi  obj }{*}: $mod.poptions += -DBOOST_${umn}_SOURCE")
      fi

      # Define `BOOST_<lib>_STATIC_LINK` on obja{} targets. Note that this
      # replaces the bdep-generated `-DBOOST_STATIC_BUILD`.
      #
      ised_ops+=(-e "s%(.+) -DBOOST_STATIC_BUILD$%\
\1 -DBOOST_${umn}_STATIC_LINK%")

      # Define `BOOST_<lib>_DYN_LINK` on objs{} targets. Note that this
      # replaces the bdep-generated `-DBOOST_SHARED_BUILD`.
      #
      ised_ops+=(-e "s%(.+) -DBOOST_SHARED_BUILD$%\
\1 -DBOOST_${umn}_DYN_LINK%")

      # Export `BOOST_<lib>_STATIC_LINK` from the liba{} target. Note that
      # this replaces the bdep-generated `-DBOOST_STATIC`.
      #
      ised_ops+=(-e "s%(.+) -DBOOST_STATIC$%\
\1 -DBOOST_${umn}_STATIC_LINK%")

      # Export `BOOST_<lib>_DYN_LINK` from the libs{} target. Note that this
      # replaces the bdep-generated `-DBOOST_SHARED`.
      #
      ised_ops+=(-e "s%(.+) -DBOOST_SHARED$%\
\1 -DBOOST_${umn}_DYN_LINK%")

      # Export the `BOOST_<lib>_NO_LIB` macro from lib{} targets.
      #
      ised_ops+=(-e "s%(.+export\.poptions.+src_pfx_inc\")$%\
\1 \\\\\n                         -DBOOST_${umn}_NO_LIB%")
    fi

    ised "$lib_bfile" "${ised_ops[@]}"

    # Create smoke test (by modifying the test generated by `bdep-new`).
    #
    # For now we just include the library's header(s) from the test driver's
    # source file and, if it compiles, we could not have missed any
    # headers. (But while developing, remember to ensure that your system
    # Boost installation isn't masking breakages.)
    #

    # Install custom test files if they exist: copy any files in
    # `downstream/libs/$udn/test/` or one of its subdirectories into
    # `<lib>/tests/`, replacing the `bdep-new`-generated ones. Note that we're
    # merging directory contents and therefore we cannot simply link to
    # directories, and also that we copy instead of symlink because, since
    # version 2.32, git ignores .gitattributes and .gitignore if they are
    # symlinks.
    #
    ctd="downstream/libs/$udn/test" # Custom test directory.
    if [[ -d "$ctd" ]]; then
      find "$ctd" -type f | while read f; do
        # Source directory path, relative to `downstream/libs/`.
        #
        # $udn/test/, $udn/test/basics/, etc
        #
        sd="$(dirname "${f#downstream/libs/}")/"

        # Destination directory, relative to `downstream/libs/<lib>/tests/`.
        #
        # <empty>, basics/, etc
        #
        dd="${sd#$udn/test/}"

        # Create the destination directory if it doesn't exist.
        #
        if [[ ! -d "$pn/tests/$dd" ]]; then
          mkdir -p "$pn/tests/$dd"
        fi

        cp "$f" "$pn/tests/$dd"
      done
    fi

    # Generate the smoke test if this package does not have a custom one.
    #
    if [[ ! -f "$ctd/basics/driver.$se" ]]; then
      # Build the include directive(s) appropriate for this library. If it
      # exists, include only the super-header (a single header which includes
      # all of its headers), otherwise include all headers in
      # `boost/include/<lib>/` and `boost/include/`.
      #
      # Based on inspection, the informal convention (if there were a formal
      # convention I would expect it to be referenced by
      # https://www.boost.org/development/requirements.html) seems to be that
      # Boost libraries should provide super-headers and that they should be
      # located either at `include/boost/<lib>/<lib>.hpp` or
      # `include/boost/<lib>.hpp`; the former appears to be more
      # conventional. Only a minority of libraries do not conform; the rest
      # have super-headers at one of the above two paths.
      #
      # Resolve the ambiguity of the super-header location by first checking
      # the `include_headers` associative array defined in the `override` file
      # for an entry for the current library. If one exists, include all
      # header paths in the entry (in most cases there will only be a single
      # path: the super-header). Otherwise first look for the super-header at
      # `include/boost/<lib>/<lib>.hpp` and then at
      # `include/boost/<lib>.hpp`. If both paths exist, fail with a message
      # suggesting that an override should be defined.
      #
      # For reference, here are some of the non-conforming libraries and the
      # ways in which they break the convention:
      #
      #   - Libraries with non-conforming super-header names: Exception
      #     (`include/boost/exception/all.hpp`)
      #
      #   - Libraries that put non-super-header(s) under `include/boost/`:
      #     Conversion, Iterator, Unordered, Math, Core, Multi-Index, ...
      #
      #   - Libraries that have what looks like a super-header but which
      #     doesn't actually include all of its headers: Utility
      #
      incl=                          # The include statement(s).
      ih=(${include_headers["$pn"]}) # Headers to include for this library.

      if [[ "${#ih[@]}" -ne 0 ]]; then
        for h in "${ih[@]}"; do
          incl+="#include <boost/$h>"$'\n'
        done
      elif [[ -f "$pn/include/boost/$udn/$udn.$he" ]]; then
        if [[ -f "$pn/include/boost/$udn.$he" ]]; then
          error "$pn appears to have two super-headers (add an override)"
        fi
        incl="#include <boost/$udn/$udn.$he>"$'\n'
      elif [[ -f "$pn/include/boost/$udn.$he" ]]; then
        incl="#include <boost/$udn.$he>"$'\n'
      else
        # No super-header found, so include all headers directly under
        # `include/boost/` and `include/boost/$udn/`.
        #
        # Find and include all public headers. All paths returned by `find`
        # will be of the `$udp/include/boost/foo.hpp` or
        # `$udp/include/boost/$udn/foo.hpp` forms.
        #
        eh=(${exclude_headers["$pn"]}) # Excluded headers for this library.

        # The value of the `-maxdepth` option to `find`. Increase it if the
        # upstream directory name is a path (for example,
        # `numeric/conversion`).
        #
        md=2
        if [[ "$udn" == *"/"* ]]; then
          md=3
        fi
        find "$udp/include/boost/" -maxdepth "$md" -type f -name "*.$he" |\
          sort |\
          while read hp; do # hp: header path.
            # Header filename, relative to `$udp/include/boost/`.
            #
            h="${hp#$udp/include/boost/}"

            # Include this header unless it has been explicitly
            # excluded. Remove the `$udp/include/` prefix from the path to
            # make it relative to `include/`.
            #
            if [[ ! "$(contains "$h" "${eh[@]}")" ]]; then
              incl+="#include <${hp#$udp/include/}>"$'\n'
            fi
          done
      fi

      # Write the test driver source file.
      #
      cat <<EOF > "$pn/tests/basics/driver.$se"
$incl
int
main ()
{
  return 0;
}
EOF
    fi
  done

  ((++level))
done

# Remove commented-out and empty lines from `repositories.manifest`. Also add
# repositories for non-Boost dependencies.
#
ised repositories.manifest \
     -e "/(^#|^$)/d" \
     -e '/^summary:.+/a\
\
:\
role: prerequisite\
location: https://pkg.cppget.org/1/stable\
trust: 70:64:FE:E4:E0:F3:60:F1:B4:51:E1:FA:12:5C:E0:B3:DB:DF:96:33:39:B9:2E:E5:C2:68:63:4C:A6:47:39:43'

# Remove the root buildfile because building all packages at once is a very
# uncommon use case and the generated buildfile does not work without
# modification.
#
rm buildfile
