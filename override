## manifest_url
##
## The url package manifest value overrides.

manifest_url["libboost-numeric-interval"]="https://github.com/boostorg/interval"
manifest_url["libboost-numeric-odeint"]="https://github.com/boostorg/odeint"
manifest_url["libboost-numeric-ublas"]="https://github.com/boostorg/ublas"

## manifest_builds
##
## The builds package manifest value overrides.
##
## If unspecified for a library, then no builds value is specified in its
## package manifest (and so the default build configuration class is assumed).
##
## Note: only one builds value can be specified for a library.
##
## @@ One value can potentially be too restrictive, but let's not complicate
##    things before it is required.

manifest_builds["libboost-winapi"]=\
"&windows ; Provides Windows API declarations."

# Instead of `!` for logical NOT, Boost.Sort uses `not`. MSVC does not support
# alternative operator representations by default and therefore code using
# Boost.Sort as-is does not compile under MSVC. This can only be worked around
# by taking measures, none of which are practical, in the client project. A
# bug has been filed at https://github.com/boostorg/sort/issues/43 but it does
# not look like they plan to fix it.
#
manifest_builds["libboost-sort"]="-msvc ; Contains code not accepted by MSVC."

## binless_libs
##
## Libraries that are binless despite having one or more source files.

# Boost.Date_Time has transitioned to header-only, leaving only a single stub
# source file, src/gregorian/greg_month.cpp, to produce a stub library for
# clients that still link against it. Confusingly there are other source files
# under src/ that are clearly not stubs, but they are not referenced from
# anywhere, so presumably these are stale source files.
#
binless_libs["libboost-date-time"]=true

binless_libs["libboost-exception"]=true

# Since 1.76 Boost.Regex is header-only but will be detected as binful because
# it still supports compilation for users with C++03 compilers or who use the
# deprecated POSIX C APIs.
#
binless_libs["libboost-regex"]=true

binless_libs["libboost-system"]=true

## cxx_only
##
## Libraries that need to be C++-only regardless of whether they are detected
## as mixed-language.
##

# Boost.Stacktrace is detected as mixed-language but it just has a few (what
# looks like to be badly-named) .h headers in detail/.
#
cxx_only["libboost-stacktrace"]=true

## source_macro
##
## The libraries that need `BOOST_<lib>_SOURCE` to be defined on the
## compilation command line.
##
## Other libraries define it unconditionally in every one of their source
## files. Do not define this macro in the latter cases otherwise the compiler
## will complain that it's been redefined. (Not all libraries define this
## macro to have the same value: most use an empty value but some use `1`).
##
source_macro["libboost-atomic"]=true
source_macro["libboost-filesystem"]=true
source_macro["libboost-json"]=true
source_macro["libboost-stacktrace"]=true

## nonboost_intf_deps
##
## Non-Boost interface dependencies.
##
## Each value is a space-separated list of dependencies in the Buildfile
## project-qualified target format, optionally with a package version
## constraint appended.
##
## If there are multiple instances of a project, only the first one's package
## version constraint will be used (and subsequent ones ignored).
##
## Although the version constraints cannot contain spaces (because these
## values are space-separated), spaces will be inserted as required in the
## `generate` script (but not around ranges).
##
nonboost_intf_deps["libboost-regex"]="\
libicuuc%lib{icuuc}^65.1.0 \
libicui18n%lib{icui18n}^65.1.0 \
"

nonboost_intf_deps["libboost-multiprecision"]="Eigen%lib{Eigen}^3.3.8"

## nonboost_impl_deps
##
## Non-Boost implementation dependencies.
##
nonboost_impl_deps["libboost-iostreams"]="\
libz%lib{z}^1.2.1100 \
libbzip2%lib{bzip2}^1.0.8 \
"

## include_headers
##
## For each library, a space-separated list of the complete set of header
## paths that must be included into the smoke test instead of those discovered
## by the `generate` script.
##
## For example, some libraries have what looks like a super-header in both
## `include/boost/<lib>/<lib>.hpp` and `include/boost/<lib>.hpp`, in which case
## this override resolves the ambiguity.
##
## The paths are relative to `include/boost/`.

include_headers["libboost-align"]="align.hpp"
include_headers["libboost-atomic"]="atomic.hpp"
include_headers["libboost-bind"]="bind/bind.hpp"
include_headers["libboost-chrono"]="chrono.hpp"
include_headers["libboost-dynamic-bitset"]="dynamic_bitset/dynamic_bitset.hpp"
include_headers["libboost-endian"]="endian.hpp"
include_headers["libboost-optional"]="optional/optional.hpp"
include_headers["libboost-phoenix"]="phoenix/phoenix.hpp"

# The comment at the top of this header says "Include the default amount of
# outcome" so it must be the super-header.
#
include_headers["libboost-outcome"]="outcome.hpp"

include_headers["libboost-ratio"]="ratio.hpp"
include_headers["libboost-stacktrace"]="stacktrace.hpp"
include_headers["libboost-static-string"]="static_string/static_string.hpp"
include_headers["libboost-test"]="test/unit_test.hpp"
include_headers["libboost-thread"]="thread.hpp"
include_headers["libboost-variant"]="variant.hpp"

## exclude_headers
##
## For each library, a space-separated list of header paths that must not be
## included directly. Like `include_headers`, the paths are relative to
## `include/boost/`.

# detail/*.hpp: deprecated headers.
#
# Note that this is the Boost.Core library, not Boost.Detail. These headers
# are in `include/boost/detail` instead of the more conventional
# `include/boost/core/detail/`.
#
exclude_headers["libboost-core"]="\
detail/iterator.hpp \
detail/lightweight_test.hpp \
detail/no_exceptions_support.hpp \
detail/scoped_enum_emulation.hpp \
detail/sp_typeinfo.hpp \
"

# lightweight_main.hpp, lightweight_test_report.hpp: these files define main().
#
# utf8_codecvt_facet.hpp: is not to be included by the user and requires some
#                         macro definitions, so it feels like testing it
#                         indirectly via other libraries is good enough.
#
exclude_headers["libboost-detail"]="\
detail/lightweight_main.hpp \
detail/lightweight_test_report.hpp \
detail/utf8_codecvt_facet.hpp \
"

# Boost.ICL's headers are sensitive to include order. Instead of trying to fix
# the order, excluding the headers below is sufficient to make the build
# succeed.
#
exclude_headers["libboost-icl"]="\
icl/associative_element_container.hpp \
icl/associative_interval_container.hpp \
icl/interval_base_map.hpp \
"

# These headers can only be included on Windows or systems with XSI shared
# memory support.
#
# The Windows-specific headers are only required to interoperate with
# processes that don't use Boost.Interprocess, so exluding these headers does
# not disable shared memory on Windows. The XSI shared memory is also a
# separate and non-default interface. (The default is the POSIX shared memory
# interface in interprocess/shared_memory_object.hpp.) So excluding these
# headers seems like the simplest way to get our smoke test to build on all
# platforms.
#
exclude_headers["libboost-interprocess"]="\
interprocess/managed_windows_shared_memory.hpp \
interprocess/windows_shared_memory.hpp \
interprocess/managed_xsi_shared_memory.hpp \
interprocess/xsi_key.hpp \
interprocess/xsi_shared_memory.hpp \
"

# function_output_iterator.hpp: deprecated header.
#
exclude_headers["libboost-iterator"]="function_output_iterator.hpp"

# random.hpp is a deprecated header; float128.hpp only works under the GCC or
# Intel compilers; complex128.hpp depends on float128.hpp; the rest are for
# backends that require unpackaged libraries.
#
exclude_headers["libboost-multiprecision"]="\
multiprecision/complex128.hpp \
multiprecision/float128.hpp \
multiprecision/gmp.hpp \
multiprecision/mpc.hpp \
multiprecision/mpfi.hpp \
multiprecision/mpfr.hpp \
multiprecision/random.hpp \
multiprecision/tommath.hpp \
"

# nowide/windows.hpp, which can only be included on Windows, is included
# conditionally by nowide/args.hpp so we do not have to include it.
#
exclude_headers["libboost-nowide"]="nowide/windows.hpp"

# checked_float.hpp: does not compile and is not used in any of Boost's own
#                    tests.
#
# range_value.hpp:   requires but does not include <ios>.
#
exclude_headers["libboost-safe-numerics"]="\
safe_numerics/checked_float.hpp \
safe_numerics/range_value.hpp \
"

# system/*_error.hpp: deprecated headers.
#
exclude_headers["libboost-system"]="\
system/cygwin_error.hpp \
system/linux_error.hpp \
system/windows_error.hpp \
"
